% Define the module top matter
% This gets used to create the chapter title page
% NOTES:
%  * When multiple people have authored or contributed to the module, simply use a LaTeX line break
%    (a double-backslash: \\) at the end of each person.
%  * If you don't want this information shown on the module chapter page, simply remove the lines
%    within the \setModuleAuthors{} and \setModuleContributions{} environments
\setModuleTitle{Introduction to Snakemake}
\setModuleAuthors{%
  Nathan S. Watson-Haigh \mailto{nathan.watson-haigh@adelaide.edu.au}
}
%\setModuleContributions{%
%  John Doe \mailto{john.dow@example.com}%
%}

% BEGIN: Module Title Page
% This simply uses the above information and creates a module chapter page
% NOTES:
%  * The chapter page will always appear on odd numbered page
\chapter{\moduleTitle}
\newpage
% END: Module Title Page


% BEGIN: KLOs
% Key Learning Outcomes (KLOs) are an important aspect of any learning/training. They provide
% valuable infomation about what the trainee will have learned, what they will be able to do or know
% abouti at the end of the module. Unlike objectives which are more trainer oriented, KOLs are
% focused on the learner.
% At the end of the module, the KLOs can be used to develop criteria for writing an assessment to
% see if the trainees knowledge/skills have improved as a result of the module.
% 
% Search online for information on how to write KLOs. e.g.
% http://www.teaching-learning.utas.edu.au/__data/assets/word_doc/0014/23333/Learning-outcomes-v9.1.doc
\section{Key Learning Outcomes}

After completing this module the trainee should be able to:
\begin{itemize}
  \item Install Snakemake in a conda environment
  \item Execute a Snakemake workflow
  \item Use the provided ``profile'' to execute jobs on a compute cluster
  \item Write simple Snakemake rules capable of generating some output(s) by executing some code which perates on some input(s)
\end{itemize}
% END KLOs

% BEGIN: Resources Used
% This section can be used to describe the tools and data used during the module. It helps to act as
% a future reference to the trainee
\section{Resources Required}

For the purpose of this training you need access to:

\begin{itemize}
  \item A compute cluster with the \texttt{module} command available to you for loading software
  \item Singularity (\url{https://sylabs.io/singularity/}) - available as a module on the above cluster
  \item Conda(\url{https://www.anaconda.com/distribution/}) - available as a module on the above cluster
\end{itemize}


\subsection{Tools Used}
\begin{description}[style=multiline,labelindent=0cm,align=left,leftmargin=0.5cm]
  \item[Snakemake]\hfill\\
    \url{https://snakemake.readthedocs.io}
  \item[Graphviz]\hfill\\
    \url{https://www.graphviz.org}
\end{description}

\section{Useful Links}
 
\begin{description}[style=multiline,labelindent=0cm,align=left,leftmargin=0.5cm]
  \item[Slurm Documentation]\hfill\\
    \url{https://slurm.schedmd.com/documentation.html}
\end{description}

\newpage
% END: Resources Used

%========================
\section{Setting Up Your Environment}
%========================

For the purpose of the workshop we will be working on the head node of an HPC cluster running slurm (\url{https://slurm.schedmd.com/documentation.html}).
This is the most likely infrastructure that fellow bioinformaticians already find themselves using
on a regular basis. We also assume that the cluster provides the \texttt{module} command for you to
load software and the modules \texttt{Anaconda3} and \texttt{Singularity} are available to use.

The execution of the Snakemake workflow will actually take place on the cluster head node with jobs
being submitted to Slurm for queing and processing. From the head node, Snakemake will monitor the
submitted jobs for their completion status and submit new jobs as dependent jobs complete sucessfully.

%------------------------
\subsection{Connect to the Cluster Head Node}
%------------------------

\begin{steps}
First up, lets connect to the head node of the HPC cluster using \texttt{ssh}.

\emph{See your local facilitator for connection details. You should have one user account per person.}
\end{steps}

%------------------------
\subsection{Install Snakemake}
%------------------------

The recommended installation route for Snakemake is through a conda environemnt
(\url{https://snakemake.readthedocs.io/en/stable/getting_started/installation.html}). As such, you need
Anaconda3, usually avaiable to you on your cluster via the module system.

\begin{steps}
\begin{lstlisting}
# We use a specific version for reproducibility reasons
# Find the latest version: https://anaconda.org/search?q=snakemake
SNAKEMAKE_VERSION="5.5.4"

# Load miniconda
module load \
  miniconda3-4.6.14-gcc-5.4.0-kkzv7zk

#####
# One-time commands to integrate conda into bash
#####
conda init bash
. ~/.bashrc
#####

# Install snakemake by submitting a job to slurm - conda is a resource hog so your HPC sysadmins
# will like you for doing this
# This might take 10-20mins
sbatch --job-name 'snakemake-install' --mem 4G --time 30:00 --wrap \
 "conda create \
  --name snakemake \
  --channel bioconda --channel conda-forge \
  --yes \
  snakemake=${SNAKEMAKE_VERSION}"
\end{lstlisting}

The above \texttt{conda create} command, submitted to slurm, will take 10-20mins to complete. 

\end{steps}

\begin{note}

You can monitor your own job(s) in the slurm queue using the slurm command `squeue`:

\begin{lstlisting}
squeue --user ${USER}
\end{lstlisting}

For convienience you are also provided with the `sq` function which produces nicer output and by default only shows your own jobs:

\begin{lstlisting}
sq

# Someone elses jobs
sq --user ${SOMEONE_ELSE}
\end{lstlisting}

If you want to see all jobs in the queue:

\begin{lstlisting}
squeue
\end{lstlisting}

\end{note}

Once your job completes successfully, snakemake installation is complete. All that is left to do is to
activate the environment which will make \texttt{snakemake} available on the command line:

\begin{steps}

\begin{lstlisting}
# Activate the newly created conda environment
conda activate snakemake
\end{lstlisting}

Integrate Snakemake autocompletion into bash:

\begin{lstlisting}
complete -o bashdefault -C snakemake-bash-completion snakemake
\end{lstlisting}

Test if Snakemake is actually working:

\begin{lstlisting}
snakemake --version
\end{lstlisting}

\end{steps}

If you experience problems with the installation, head to the Troubleshooting section for help.

\begin{bonus}
While waiting for others to catch up, why not have a look into how you would go about updating \texttt{Snakemake}
within this conda environment if there is a new version available.

\begin{answer}
\begin{lstlisting}
conda update \
  --channel bioconda --channel conda-forge \
  snakemake
\end{lstlisting}
\end{answer}

\end{bonus}


%------------------------
\subsection{Hello (Snakemake) world}
%------------------------

Lets get going with running a really simple ``Hello, world!'' example workflow. The workflow creates multiple ``world.txt'' files each in a
different subdirectory and each with different content.

\begin{steps}

\begin{lstlisting}
mkdir -p /shared/${USER}
cd /shared/${USER}
git clone https://github.com/nathanhaigh/snakemake-hello-world
cd snakemake-hello-world

# Run the workflow for real
snakemake

# Lets look at the file contents
cat */world.txt
\end{lstlisting}

\end{steps}

%========================
\section{Snakemake basics}
%========================

The way Snakemake runs can be thought of as being somewhat like a satellite navigation system, you request a destination
(``target'') and the system works out a route to get you there using its knowledge of the roads (``dependancies'') which
link together towns (``files'').

%------------------------
\subsection{Rule Definition}
%------------------------

By convention, we use a file called \texttt{Snakefile} to define our workflow rules. ``Rules'' define how to
create output files from input files. For example:

\begin{lstlisting}
rule alsen_mapping:
	input:
		ref = "references/reference.fasta.gz",
		r1  = "raw_reads/Alsen_R1.fastq.gz",
		r2  = "raw_reads/Alsen_R2.fastq.gz",
	output:
		"mapped/Alsen.bam",
	shell:
		"""
		bwa mem {input.ref} {input.r1} {input.r2} \
		  | samtools view -b > {output}
		"""
\end{lstlisting}

The shell commands (line 10-11) operate on the input files (defined in lines 2-5) to create the output file (defined in lines 6-7). Input and output
file names can be referenced using the curly brace syntax shown within the \texttt{shell} definition.

%------------------------
\subsection{Targets}
%------------------------

Targets are the files we can ask the Snakemake workflow to create. In the previous example, the rule defines an explicit
output file which can be used as a ``target'' when executing the workflow:

\begin{lstlisting}
snakemake \
  mapped/my.bam
\end{lstlisting}

Snakemake will process all the dependencies defined by the rules to create a Directed Acyclic Graph (DAG) of the job dependencies and determine which
rules need to be executed in order to create the requested \texttt{target}. If no \texttt{target} is specified, Snakemake will simply execute the first
rule in the \texttt{Snakefile}. In addition, the first rule in the \texttt{Snakefile} is also given an alias of \texttt{all}. Thus the following commands
are equivillent to the one show above:

\begin{lstlisting}
snakemake
snakemake all
\end{lstlisting}

Rules which only define \texttt{input} fiels are called pseudo-rules. These provide a convienient way to define a set of \texttt{target} files by simply
referencing the rule name as the target. For instance the following \texttt{Snakefile} defines two rules for creating two different BAM files from
different inputs:

\begin{lstlisting}
rule mapping:
	input:
		"mapped/Alsen.bam",
		"mapped/Baxter.bam",

rule alsen_mapping:
	input:
		ref = "references/reference.fasta.gz",
		r1  = "raw_reads/Alsen_R1.fastq.gz",
		r2  = "raw_reads/Alsen_R2.fastq.gz",
	output:
		"mapped/Alsen.bam",
	shell:
		"""
		bwa mem {input.ref} {input.r1} {input.r2} \
		  | samtools view -b > {output}
		"""

rule baxter_mapping:
	input:
		ref = "references/reference.fasta.gz",
		r1  = "raw_reads/Baxter_R1.fastq.gz",
		r2  = "raw_reads/Baxter_R2.fastq.gz",
	output:
		"mapped/Baxter.bam",
	shell:
		"""
		bwa mem {input.ref} {input.r1} {input.r2} \
		  | samtools view -b > {output}
		"""
\end{lstlisting}

The pseudo-rule (\texttt{mapping}) can be used as a \texttt{target} when executing the workflow:

\begin{lstlisting}
snakemake mapping
\end{lstlisting}

Remember that the first rule defined in the \texttt{Snakefile} is also given the alias \texttt{all}, so the following is equivilent:

\begin{lstlisting}
snakemake all
\end{lstlisting}

Because both the \texttt{mapping} and \texttt{all} targets refer to the same files, to avoid confusion it is convention to all the
first rule \texttt{all}, thus the above \texttt{Snakefile} would more accuratly be written as:

\begin{lstlisting}
rule all:
	input:
		"mapped/Alsen.bam",
		"mapped/Baxter.bam",

rule alsen_mapping:
	input:
		ref = "references/reference.fasta.gz",
		r1  = "raw_reads/Alsen_R1.fastq.gz",
		r2  = "raw_reads/Alsen_R2.fastq.gz",
	output:
		"mapped/Alsen.bam",
	shell:
		"""
		bwa mem {input.ref} {input.r1} {input.r2} \
		  | samtools view -b > {output}
		"""

rule baxter_mapping:
	input:
		ref = "references/reference.fasta.gz",
		r1  = "raw_reads/Baxter_R1.fastq.gz",
		r2  = "raw_reads/Baxter_R2.fastq.gz",
	output:
		"mapped/Baxter.bam",
	shell:
		"""
		bwa mem {input.ref} {input.r1} {input.r2} \
		  | samtools view -b > {output}
		"""
\end{lstlisting}


%------------------------
\subsection{Wildcards}
%------------------------

The above example \texttt{Snakefile} contains two almost identical rules with the only difference being that the first rule is for input/output
files containing \texttt{Alsen} in theor paths, while the second rule is for input/output files containing \texttt{Baxter} in theor paths. This
seems like an awful lot of redundant code for executing the same commands but on different files. Snakemake provides ``wildcards'' which are
specified using curly braces in the \texttt{output} file paths and then reused within the \texttt{input} file paths and other parts of a rule
definition.

Therefore, the two mapping rules defined in the above \texttt{Snakefile} can be generalised with the use of a \texttt{wildcard}, which we
call \texttt{accession}, as follows:

\begin{lstlisting}
rule all:
	input:
		"mapped/Alsen.bam",
		"mapped/Baxter.bam",

rule generalised_mapping:
	input:
		ref = "references/reference.fasta.gz",
		r1  = "raw_reads/{accession}_R1.fastq.gz",
		r2  = "raw_reads/{accession}_R2.fastq.gz",
	output:
		"mapped/{accession}.bam",
	shell:
		"""
		bwa mem {input.ref} {input.r1} {input.r2} \
		  | samtools view -b > {output}
		"""
\end{lstlisting}

This generalisation, now also means we can potentially specify an infinate number of \texttt{targets} on the commandline:

\begin{lstlisting}
snakemake \
  Gladius.bam \
  something_obscure.bam \
  get_more_crazy.bam
\end{lstlisting}






\begin{bonus}

If you're storming ahead of everyone else, why not take a look at these bonus questions/tasks:

\begin{questions}
Look at the \texttt{snakemake} help, what commandline argument would you use for snakemake to show the reason for
a rule being executed?
\end{questions}

\begin{answer}
\begin{lstlisting}
snakemake --reason
\end{lstlisting}
\end{answer}

\begin{questions}
Without modifying the \texttt{Snakefile}, how might you create new Hello, world files using a different \texttt{cheer} such as
\texttt{cześć} which is Polish for ``hello''?
\end{questions}

\begin{answer}
\begin{lstlisting}
snakemake --reason \
  czesc/world.txt
\end{lstlisting}
\end{answer}

\end{bonus}


%========================
\section{Example Workflow}
%========================

We are going to work with an example Snakemake workflow to demonstrate how they are run before
we get stuck into writing our own. This example workflow consists of the following steps:

\begin{itemize}
  \item Running FastQC across the raw reads
  \item Aggregating the raw read FastQC reports using MultiQC
  \item Performing adapter, quality, and read length filtering using Trimmomatic
  \item Running FastQC across the QC'd reads
  \item Aggregating the QC read FastQC reports using MultiQC
  \item Index the reference FASTA file
  \item Perform a \texttt{bwa-mem} read alignment
\end{itemize}

\begin{steps}

Lets get the example workflow:

\begin{lstlisting}
# Clone the repository
git clone https://github.com/UofABioinformaticsHub/2019_EMBL-ABR_Snakemake_webinar ./example_workflow

cd example_workflow/snakemake-tutorial
\end{lstlisting}

The most basic of Snakemake commands will execute the workflow, running jobs on the head node (your cluster
sysadmin will probably growl at you). Lets be nice, and just do a \texttt{dryrun} for now:

\begin{lstlisting}
snakemake \
  --dryrun
\end{lstlisting}
\end{steps}

\begin{questions}

Using the Snakemake help, how do you get Snakemake to print the shell commands it will execute for each job?

\begin{answer}
\begin{lstlisting}
snakemake \
  --dryrun \
  --printshellcmds
\end{lstlisting}
\end{answer}

\end{questions}

%========================
\section{Modify/extend the Workflow}
%========================

%========================
\section{Your own Workflow}
%========================

%========================
\section{Troubleshooting}
%========================

\subsection{Snakemake Install}

If you have a broken or incomplete snakemake installation, try the following steps to fix things:

\begin{lstlisting}
# deactivate the snakemake conda environment if it is already active
conda deactivate

# Delete the snakemake conda environment
conda env remove --name snakemake
\end{lstlisting}

Now try reinstalling snakemake.

\subsection{Conda Software Environment Setup}

If your job failed or timed out, you will need to re-run conda software environment setup job again. However, you may first need to release the
Snakemake lock which protects you from running multiple instances of the same workflow at the same time:

\begin{lstlisting}
snakemake \
\end{lstlisting}
```

To ensure Snakemake starts with a clean slate, delete the ``hidden'' \texttt{.snakemake} directory:

\begin{lstlisting}
rm -rf .snakemake
\end{lstlisting}
